## 时间复杂度

### 什么是算法
算法(algorithm)，在`数学`和`计算机科学`中，为任何良定义的具体计算步骤的一个序列，常用与计算、数据处理和自动推理。准确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰的指令用于计算函数。   
算法中的指令描述的是一个计算，当其运行时能从一个初始状态和初始输入（可能为空）开始，经过一系列有限而清晰定义的状态最终产生输出并停止于一个状态。

![应对灯泡不亮的算法](https://raw.githubusercontent.com/mxjesse/mxjesse.github.io/master/img_folder/201906/1561019795416.jpg)

由于担心描述不准确，以上摘自[维基百科-算法](https://zh.wikipedia.org/wiki/算法)，简单来说，算法就是一系列被控制的步骤，你通过按序执行这些步骤可以实现一些目标或者产生一些输出。

### 大O表示法

大O表示法使用大写字母O，可以认为其含义为"order of"（大约是）。我们可以使用大O法来描述线性查找使用了O(N)级时间，二分查找使用了O(log N)级时间，向一个无序数组中插入使用了O(1)，下边详细分析大O表示法。

大O表示法就是将算法的所有步骤都转化为数字，然后排除不会对问题复杂度产生较大影响较低的低阶常数和系数，在软件开发中都使用此方法表示复杂度以简化问题所在，大概估算程序运行开始至结束耗费的时间。

```
例如：

5			O(1)		--> 常数
3n+23		O(n)		--> n对结果产生较大影响，常数和系数忽略
7n^2		O(n^2)		--> n^2影响最大，系数忽略
```
所以，大O表示法只关注表达式中对表达式最终结果产生较大影响的因子（当然会有系数很大，而n很小的情况在，但是系数级别和计算机运算速度一般忽略不计，不考虑这种情况）

下边给出常用的时间复杂度的定义：

* **O(1)** --> `常量时间`，给一个大小为n的输入，计算机大概一步就可完成
* **O(log n)** --> `对数时间`，给定大小为n的输入，该算法每执行一步，它完成任务需要的步骤会以一定的因子减少
* **O(n)** --> `线性时间`，给定大小为n的输入，该算法完成需要的步骤数直接和n相关（1对1关系）
* **O(n^2)** --> `二次方时间`，给定大小为n的输入，完成需要的步骤是n的平方
* **O(C^n)** --> `指数时间`，给定大小为n的输入，完成任务所需要的步骤是一个常数的n次方

```
举个例子：
如果一个计算的 n=9
O(1）= 1 //1
O(log 9) = 3
O(n) = 9
O(n^2) = 81
O(2^n) = 512
随着时间复杂度增加，可以看到需计算机执行的步骤是成数量级增长的，耗费在计算的时间理论上也更长
```

用Java代码来举例，分析下大O表示法怎么衡量时间：

```
int sum = 0;
for (int i = 0; i < n; i++) { //暂且不管n为多大，假设为无限大
	sum += i;
}
```
计算执行代码需要的时间，首先我们假定计算机执行每个代码步骤都是一样的单位时间（处理速度很快）：   

1. 第一行代码`sum=0`为赋值操作，记1个单位时间
2. 第二行for循环的参数里，有一个赋值`i=0`的操作，记1个单位时间；`i<n`的比较操作要做n+1次，记n+1个单位时间；`i++`要做n次，记n个单位时间
3. 第三行`sum+=i`其实有两个操作，一个`sum+i`记n个单位时间，一个`sum=sum+i`赋值操作记n个单位时间，共2n个单位时间
 
以分析可以得出以上三部分代码要执行一共4n+3个单位时间，按照我们上边大O表示法表达，去掉常数和系数则,此代码的时间复杂度为O(n)。该代码非常简单，实际在我们工作中代码的时间复杂度难以像以上代码这样可以直接数出来，我们可以依据时间复杂度定义来计算时间复杂度。

#### O(1) 常数时间
简单来说无论代码执行多少行，只要没有循环等结构，都可以认为时间复杂度为O(1)，如：

```
int i = 0;
int j = 100;
i++;
++j;
i = i + j;
j = j + 100;
int sum = i + j;
```

#### O(log n) 对数时间
对数时间，就是剩余执行时间每次减少，在Java中二分查找法就是如此，简单例子如：

```
int i = 1;
while ( i < n) {
	i = i * 2;
}
```
n 如果为100，`i<n`比较操作8次就可以完成，n越大，需要的比较次数成指数减少  
**ps**：在这里不要纠结log的底是多少，只是一个指数化的对比，与`C^n`相反

#### O(n) 线性时间
如果代码中有循环，循环次数为n，那么时间复杂度为O(n)，如：

```
int sum = 0;
for (int i = 0; i < n; i++) {
	sum += i;
}
```

#### O(n^2) 平方阶时间
平方阶很好举例，在Java代码中一个循环套一个循环，就是这样，如：

```
int sum = 0;
for (int i = 0; i < n; i++) {
	for (int j = 0; i < n; i++) {
		int temp = j;
		sum = sum + temp;
	}
}

```
按照平方阶也可以推断出立方阶段 `O(n^3)`，k次方阶`O(n^k)`

#### O(C^n) 指数时间
O(2^n)表示一个算法的性能将会随着输入数据的每次增加而增大两倍。O(2^n)的增长曲线是一条爆炸式增长曲线——开始时较为平滑，但数据增长后曲线增长非常陡峭。一个典型的O(2^N)方法就是裴波那契数列的递归计算实现,如下：

```
public int calculate(int n) {
	if (n < 1) {
		return n;
	} else {
		return calculate(n-1) + calculate(n-2);
	}
}
```
按照这个也可以推断出O(3^n)，不再举例了。

#### 总结
时间复杂度的关系如下：
`O(1) < O(log n) < O(n) < O(n * log n) < O(n^2) < O(n^3) < O(2^n) < O(3^n) < O(n!)`，耗费的时间越来越长，O(1)级时间的算法是最好的，O(log(N))次之，O(N)为一般，O(N平方)最差。

一些普通算法运行时间复杂度：
![一些普通算法运行时间复杂度](https://raw.githubusercontent.com/mxjesse/mxjesse.github.io/master/img_folder/201906/3972038627-5c6a7910b5ccb_articlex)

有兴趣的可以看看时间复杂度大O表达式的图表，参考链接[大O表示法查看表](http://bigocheatsheet.com)，如下图：
![一些普通算法运行时间复杂度](https://raw.githubusercontent.com/mxjesse/mxjesse.github.io/master/img_folder/201906/1561022725943.jpg)
