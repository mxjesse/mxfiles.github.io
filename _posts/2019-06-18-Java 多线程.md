## Java 多线程

### 基本概念

线程和进程大家都了解的很多了，这里引用wiki百科的说明。

**进程（process）**：是指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；在面向线程设计的系统（如当代多数操作系统、Linux 2.6及更新的版本）中，进程本身不是基本运行单位，而是线程的容器。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。若干进程有可能与同一个程序相关系，且每个进程皆可以同步（循序）或异步（平行）的方式独立运行。现代计算机系统可在同一段时间内以进程的形式将多个程序加载到存储器中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机体系结构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上）。  	
<https://zh.wikipedia.org/wiki/行程>

**线程（thread）**：是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。

线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。
folder
同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。

一个进程可以有很多线程，每条线程并行执行不同的任务。

在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见的，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。  
<https://zh.wikipedia.org/wiki/线程>

**并发（concurrent）**：实质是一个CPU在若干道程序（或线程）之间多路复用，并发是对有限的物理资源强行多用户共享使用以提高效率。

**并行（parallel）**：两个或两个以上的事件（或线程）在同一时刻发生，是真正意义上的不同事件或线程在同一时刻，在不同CPU资源上（多核）同时执行。

引用一幅图来描述下:  	
![Github上引用的并发并行将截图](https://raw.githubusercontent.com/mxjesse/mxjesse.github.io/master/img_folder/201906/01001508-e1a4c7ed78274ec4aa325b928af044e5.png)

**线程安全**：指在并发情况下，该代码经过多线程的使用，线程的调度顺序不影响结果。这时，我们只用关注系统内存，CPU是否够用即可。

**线程不安全**：意味线程的调度顺序影响最终结果。

### 线程状态
1. **新建（NEW）**：创建了一个线程对象
2. **可运行（RUNNABLE）**：创建线程后，其他线程（例如main线程调用了线程的start()方法，则该状态线程位于可运行的线程池中，等待被线程调度选中，获取CPU的使用权。
3. **运行（RUNNING）**：可运行状态（RUNNABLE）的线程获得了CPU时间片（TimeSlice），执行线程代码。
4. **阻塞（BLOCKED）**：阻塞状态是处于运行状态（RUNNABLE）状态的线程因为某原因放弃了CPU的使用权，即让出了TimeSlice，暂时停止运行，直到线程进入可运行状态（RUNNABLE），方才有机会再次获得TimeSlice转到运行状态（RUNNING），阻塞情况分为以下三种：
	1. 等待阻塞：运行状态（RUNNING）的线程执行了obj.wait()方法，JVM会把该线程放到等待队列（waitting queue）中；
	2. 同步阻塞：运行状态（RUNNING）的线程在获取对象的同步锁时，如果该同步锁被其他线程占用，则JVM会把该线程放进锁池（lock pool）中；
	3. 其他阻塞：运行状态（RUNNING）的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()超时、join()等待线程终止或者超时、或I/O处理完毕时，线程重新进入可运行状态（RUNNABLE）。
5. **死亡（DEAD）**：线程run()方法运行结束，或因异常退出了run()方法，则线程结束生命周期，死亡的线程不能再次复活。